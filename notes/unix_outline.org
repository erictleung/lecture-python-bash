#+TITLE: Linux/Unix Command and Bash Scripting Overview
#+AUTHOR: Eric Leung
#+DATE: 2018-08-11
#+PROPERTY: header-args :results value drawer replace :exports results :tangle yes

* Unix and Linux Background

- Unix is operating system developed at Bell labs in 1970s

- Linux developed in 1991 by Finnish-American programmer and computer scientist
  Linus Torvalds
  - Linux and derivations are Unix-like, which act very much like original Unix
    operating system

- Multiple "flavors" of Linux with different purposes and uses
  - Ubuntu = general purpose
  - elementary OS = fast and open replacement for Windows and macOS
  - Arch Linux = simple, lightweight distribution
  - More at https://distrowatch.com/

- Linux mascot is Tux the penguin

- Linux is widely used in scientific computing
  - Free (price and in source code) operating system
  - Decades of development and debugging
  - Configuration is arguably easier

* Basic Linux Commands
** Navigation Commands

When you're confronted with a terminal, here are a few basic commands to get
you around your computer.

| Command | Description             | Plain Words                         |
|---------+-------------------------+-------------------------------------|
| pwd     | Print working directory | Your location in your computer      |
| ls      | List directory contents | Look at what's around your location |
| cd      | Change directory        | Move your position in your computer |

In sum, the above commands help you navigate around your computer.

*** pwd

You can use ~pwd~ to show you where you are in your computer.

#+BEGIN_SRC sh
  pwd
#+END_SRC

#+RESULTS:
: /home/leunge/documents/github/lecture-python-bash/notes

*** ls

After knowing where you are, you should find out what files and directories are
around you.

You can use various options to change the output depending on what is
interesting to you.

| Option | Description                          |
|--------+--------------------------------------|
| -l     | Format into a list                   |
| -a     | List all files e.g. hidden dot files |
| -t     | Order by last time modified          |
| -r     | Reverse order results                |
| -X     | Group by file type/extension         |

#+BEGIN_SRC sh
  ls
#+END_SRC

#+RESULTS:

*** cd

It is no use if you can't go any where, so let's start moving around the
computer using ~cd~.

Here are some key character to know when using ~cd~.

- . (single period) :: this is where you are currently
  - E.g. ~cd .~ = stays where you are
- .. (double period) :: go up the parent directory
  - E.g. ~cd ..~ = goes up

#+BEGIN_SRC sh
  pwd
  cd ../
  pwd
#+END_SRC
** Echo and File Exploration

Now that we have some files, we can take a look at files using a variety of
commands.

#+CAPTION: Commands to print lines of files
#+NAME: fig:echocat
| Command | Description                               |
|---------+-------------------------------------------|
| echo    | Displays lines                            |
| head    | Pirnts first few lines                    |
| cat     | Prints entire file and concatenates files |

*** echo

The ~echo~ command displays lines of text.

Some reasons you may want to use ~echo~ are:

- output messages to the screen
- printing file names

#+BEGIN_SRC sh
  echo "Hello, World!"
#+END_SRC

#+RESULTS:
:RESULTS:
Hello, World!
:END:

*** head

The ~head~ commands will show just the beginning lines of a given file.

By default, this command will show the first 10 lines of a file.

#+BEGIN_SRC sh
  head ../README.md
#+END_SRC

#+RESULTS:
:RESULTS:
# Teaching Python's NetworkX and Bash

Lecture  materials for teaching Python's NetworkX package and Bash scripting.


**Contents**

- [Requirements](#requirements)
- [Environment Setup](#environment-setup)
    - [Anaconda and Conda](#anaconda-and-conda)
:END:

*** cat

If you want to see more than just the first few lines of a file, you can use
the ~cat~ command to print out the entire file.

This command can also be used to *concatenate* or join multiple files
together.

#+BEGIN_SRC sh :results drawer
  cat ../README.md ../README.md
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

** File Manipulations

Once you're able to move aroudn you computer, let's move around files and
perform very simple changes to your files.

| Command | Description                  | Plain Words                        |
|---------+------------------------------+------------------------------------|
| touch   | Change file timestamps       | Create new file if none existed    |
| cp      | Copy files and directories   | Make clones of everything          |
| mv      | Move (and rename) files      | Change where files are in computer |
| rm      | Remove files or directorires | Delete files and be cautious using |
| mkdir   | Make directories             | Create new positions/folders       |
| rmdir   | Remove empty directories     | Remove empty folders on computer   |

In sum, the above commands help create, move, and delete files and directories.

*** touch

Moving around your computer is great and all, but without files to open and
edit, it can be kind of boring.

The ~touch~ command is used for creating empty files quickly.

This can be useful in creating a skeleton of an analysis workflow.

#+BEGIN_SRC sh
  touch new_file_1.txt
  ls
#+END_SRC

#+RESULTS:

*** cp

Now that we have some files, you can create more with ~cp~.

The ~cp~ command is used to *copy* files and directories.

#+BEGIN_SRC sh
  cp new_file_1.txt new_file_2.txt
  ls
#+END_SRC

*** mv

The ~mv~ command is used to *move* files and directories around your computer.

Another use for this command is to *rename* things on your computer.

#+BEGIN_SRC sh
  mv new_file_2.txt new_file_2_update.txt
  ls
#+END_SRC

*** rm

The ~rm~ command *removes*/*deletes* files and directories around your
computer.

This command is very powerful so use with caution. There are lots of jokes with
telling new coders to just delete their entire computer or database. Don't fall
for this.

#+BEGIN_SRC sh
  rm new_file_2_update.txt
  ls
#+END_SRC

*** mkdir and rmdir

Creating lots of files can get messy, so having an organization structure with
folders can help keep your files tidy.

The ~mkdir~ command *makes* directories, while the ~rmdir~ command *removes*
(empty) directories.

Let's create a new directory with ~mkdir~.

#+BEGIN_SRC sh
  mkdir new_dir
  cd new_dir
  pwd
#+END_SRC

We may eventually want to remove a directory for various reasons. We can remove
*empty* directories using the ~rmdir~ command, which is similar and more
limited than the ~rm~ command we just learned about.

#+BEGIN_SRC sh
  rmdir new_dir
  ls
#+END_SRC

** File Permissions

File permissions can be a foreign concept, especially when you've never
encountered them before or it's never affected you.

Some uses of file permissions you may encounter are:

- limit certain files for particular people
- limit who can modify files or directories

In sum, file permissions are useful for enabling a bit of security by
controlling what files can be accessed and use by who.

File permissions are properties of every file/directory on your computer and
dictate *what* (type of action) can be done by *who* (groups). There are three
groups for each type of action and types of groups.


*** Permission Types

There are three permission types:

- read (r) :: user's capability to read the contents of file/directory
- write (w) :: user's capability to write or change a file/directory
- execute (x) :: user's capability to execute a file or view the contents of a
                 directory

*** Permission Groups

There are three permission groups:

- owner/user (u) :: personal owner of the file/directory
- group (g) :: group of users who have access to file/directory
- other users (o) :: users not in file's group
- all users (a) :: what is accessible to any user, independent of group

*** chmod

Let's create file to play around with its file permissions.

#+BEGIN_SRC sh
  touch restricted_file.txt
  ls -l
#+END_SRC

The ~chmod~ command stands for *change file mode*, which refers to the number
of modes (or types) of permissions a file can have.

This allows you to specify *who* has which permission *type*.

There are two ways to manipulate a file/directory's:

- Octal representation :: using binary and numbers
- Symbolic representation :: letters and semantics (easier to remember, IMO)

**** Update with octal representation

Octal representation makes use of a base-8 number system to represent the three
types of permissions for each of the groups. Each base-8 number is a digit from
0 to 7.

The power of this representation is in its conciseness, representing all
possible combination of permission types into one number.

Each number can be constructed using *three binary numbers* from each of the
three types of permissions.

Table below summarized all possible combinations.

#+CAPTION: Summary of write persmissions and numbers, read from left to right.
#+NAME: fig:chmod
| Permission               | rwx | Binary | Number |
|--------------------------+-----+--------+--------|
| read, write, and execute | rwx |    111 |      7 |
| read and write           | rw- |    110 |      6 |
| read and execute         | r-x |    101 |      5 |
| read only                | r-- |    100 |      4 |
| write and execute        | -wx |    011 |      3 |
| write only               | -w- |    010 |      2 |
| execute only             | --x |    001 |      1 |
| none                     | --- |    000 |      0 |

Another way to look at this is using just numbers:

- read = 4
- write = 2
- execute = 1

When crafting the correct number, you can follow this general workflow:

- figure out what kind of permissions you want,
- organize these permissions into the structure (read, write, execute),
- translate values to binary,
- translate binary to octal.

Each number can then be used to represent each of the three categories of
people: user, group, and others (in that order).

For example, to give *read,write* (4 + 2 = 6) to user and just *read* (4) to
both group and others, you can run the following command with ~chmod~:

#+BEGIN_SRC sh
  chmod 644 restricted_file.txt
  ls -l
#+END_SRC

**** Update using symbolic representation

You can also use what is called symbolic representation to modify permissions.

This can be easier to remember and use because you don't have to remember which
permission equals what number and how to put together the number as well.

All you need to remeber are letters for both the different roles.

| Letter | Role   |
|--------+--------|
| u      | user   |
| g      | group  |
| o      | others |

And different permissions:

| Letter | Permission |
|--------+------------|
| r      | read       |
| w      | write      |
| x      | execute    |

All you need now is to use the following arithmetic symbols to change the
permissions:

- + :: add permission in addition to current permissions
- - :: remove permission from current permissions
- = :: add and remove unmentioned permissions

To do the same from above

#+BEGIN_QUOTE
...to give *read,write* (4 + 2 = 6) to user and just *read* (4) to both group
and others, ...
#+END_QUOTE

you can run the following:

#+BEGIN_SRC sh
  chmod u=rw,g=r,o=r restricted_file.txt
  ls -l
#+END_SRC

**** Resources and more

- [[https://www.thegeekstuff.com/2010/06/chmod-command-examples/][7 Chmod Command Examples for Beginners (The Geek Stuff)]]
- [[https://www.thegeekstuff.com/2010/04/unix-file-and-directory-permissions/][Beginners Guide to File and Directory Permissions (The Geek Stuff)]]
- [[http://examplenow.com/chmod/][Examples of chmod (examplenow)]]

** Environment Variables

Environment variables hold information for your computer to read and make
decisions about.

You can use the ~env~ command to see all created environmental variables.

One important environmental variable is your ~PATH~ variable. This variable
controls how your computer searches for programs/software.

#+BEGIN_SRC sh
  which python
#+END_SRC

#+RESULTS:

You can access environment variables using the dollar sign, ~$~, in front of
the variable name.

#+BEGIN_SRC sh
  echo $PATH
#+END_SRC

You can manipulate your path variable with an equals sign, ~=~, to append new
parts of the path to the new one using a colon, ~:~.

#+BEGIN_SRC sh
  echo $PATH
  PATH=~/bin:$PATH
  echo $PATH
#+END_SRC

Close your terminal. Are changes to your path still there?

For changes to be seen from any script and subshell called from this shell,
you'll need to *export* your path variable.

#+BEGIN_SRC sh
  export PATH
#+END_SRC

* Redirect Input and Output

Sometimes when running commands, you want to chain together multiple
commands. Rather than saving the output, opening and reading it again, and then
processing the results, you can just *redirect* output of one command into
another.

** Standard Streams

*Streams* are different types of information or data traveling within the Linux
shell. 

There are three standard streams of information:

- STDIN :: standard input e.g. keyboard
- STDOUT :: standard output e.g. screen
- STDERR :: standard error

** Redirection of Streams

Now that we have an understanding of the basic streams of data available to us,
we can redirect these streams however we like using the less than and greater
than symbols.

#+CAPTION: Summary of different types of redirections
#+NAME: tab:redirection
| Write Status | Symbol | Description     |
|--------------+--------+-----------------|
| Overwrite    | >      | Standard output |
| Overwrite    | <      | Standard input  |
| Overwrite    | 2>     | Standard error  |
| Append       | >>     | Standard output |
| Append       | <<     | Standard input  |
| Append       | 2>>    | Standard error  |

*** Output and Overwrite with >

You can use the ~>~ (greater than symbol) character to take the output of one
program to output and write to another file.

#+BEGIN_SRC sh
  ls ../ > list_of_files.txt
  head list_of_files.txt
#+END_SRC

#+RESULTS:
| notebooks |
| notes     |
| README.md |
| src       |

*** Output and Append with >>

The single greater than sign will overwrite the files you redirect to. But what
if you want to just keep on adding to a list?

That's where the double greater than sign ~>>~ comes in.

This double greater than sign will add to the bottom of the file.

#+BEGIN_SRC sh :results drawer
  # The -e flag tells echo to interpret the backslash
  echo -e "\nCompare with sorted list" >> list_of_files.txt

  ls -lt ../ >> list_of_files.txt
  cat list_of_files.txt
#+END_SRC

#+RESULTS:
:RESULTS:
notebooks
notes
README.md
src

Compare with sorted list
total 8
drwxr-xr-x+ 1 leunge Domain Users    0 Sep  5 13:01 notes
drwxr-xr-x+ 1 leunge Domain Users    0 Aug 23 15:49 notebooks
drwxr-xr-x+ 1 leunge Domain Users    0 Aug 23 15:37 src
-rw-r--r--+ 1 leunge Domain Users 2234 Aug 23 10:45 README.md
:END:

*** Input with <

You can also redirect files *into* commands using the less than symbol, ~<~.

#+BEGIN_SRC sh
  head < list_of_files.txt
#+END_SRC

#+RESULTS:
:RESULTS:
notebooks
notes
README.md
src

Compare with sorted list
total 8
drwxr-xr-x+ 1 leunge Domain Users    0 Sep  5 13:01 notes
drwxr-xr-x+ 1 leunge Domain Users    0 Aug 23 15:49 notebooks
drwxr-xr-x+ 1 leunge Domain Users    0 Aug 23 15:37 src
:END:

Now although this example is superfluous, I hope the concept still shines
through.

** Pipe

The pipe character, ~|~ (generally found above the Enter key), help redirect
output from one command to another

Let's look at what we have so far in our directory.

#+BEGIN_SRC sh :results drawer
  ls
#+END_SRC

#+RESULTS:
:RESULTS:
#unix_outline.org#
list_of_files.txt
unix_outline.org
:END:

Now, say I only want to look at only two entries with the ~head~ command.

#+BEGIN_SRC sh :results drawer
  ls | head -n 2
#+END_SRC

#+RESULTS:
:RESULTS:
#unix_outline.org#
list_of_files.txt
:END:

** Resources and More

- [[https://www.guru99.com/linux-redirection.html][Input Output Redirection in Linux/Unix Examples (Guru99)]]
- [[https://www.digitalocean.com/community/tutorials/an-introduction-to-linux-i-o-redirection][An Introduction to Linux I/O Redirection (Digital Ocean)]]
- [[https://robots.thoughtbot.com/input-output-redirection-in-the-shell][Input/Output Redirection in the Shell (thoughtbot)]]
- [[https://en.wikipedia.org/wiki/Pipeline_(Unix)][Pipeline (Wikipedia)]]
- [[http://www.catonmat.net/blog/bash-one-liners-explained-part-three/][Bash One-Liners Explained, Part III: All about redirections]]

* File Manipulation with Built-In Tools

We now have a basic understanding of how to move around our computer using the
command line, explore files, and manipulate data to go where we want.

Here, let us explore powerful tools to manipulate text files. Many of these
functions are available in Python and R, but here we can show the exact same
functionality with time-tested tools.

** awk

The ~awk~ command line tool is a powerful tool for processing text files,
especially those organized into rows and columns i.e. tabular data.

*** General syntax

Borrowed from [[https://dev.to/rrampage/awk---a-useful-little-language-2fhf][Raunak Ramakrishnan]], their blog post has broken down how ~awk~
works in terms of Python pseudocode.

#+BEGIN_SRC python
initialize()                             # Initializes variables in BEGIN block
for line in input_lines:                 # Divides input into a list of lines
    for condition, action in conditions: # Just list of condition-action pairs
        if condition(line):              # Match line against condition
            action()                     # Perform action on match 
#+END_SRC

In other words, ~awk~ is a sequence of *pattern-action* pairs where it checks
each line if it matches some pattern. If it does, the action will be executed.

#+BEGIN_SRC txt
  BEGIN {...}
  CONDITION {action}
  CONDITION {action}
  END {...}
#+END_SRC

*** Built-in variables

There are some built-in variables that can be used to make using ~awk~ more
powerful. These variables relate to the file itself, such as the number of
columns/fields in the file, which may be useful in manipulating the file.

| Variable | Description                       | Example                          |
|----------+-----------------------------------+----------------------------------|
| FS       | Input separator                   | ~awk 'BEGIN{FS="FS";}'~          |
| OFS      | Output separator                  | ~awk 'BEGIN{OFS="=";}'~          |
| RS       | Determines what is a record       | ~awk 'BEGIN{RS="\n\n";}'~        |
| ORS      | Output record separator           | ~awk 'BEGIN{ORS="=";}'~          |
| NR       | Number of record                  | ~awk '{print "Number - ", NR;}'~ |
| NF       | Number of fields/columns          | ~awk '{print NR,"->",NF;}'~      |
| FILENAME | Name of current file              | ~awk '{print FILENAME}'~         |
| FNR      | Number of records rel. to current | ~awk '{print FILENAME, FNR;}'~   |
| $0       | The entire line                   | ~awk '{print $0;}`~              |
| $n       | The nth field number              | ~awk '{print $1;}'~              |

*** Examples

Now that we have the general syntax, let's try out some ~awk~ commands.

#+BEGIN_SRC sh :results drawer
  ls -l
  ls -l | awk '{ print $6 " " $10 }'
  ls -l | awk '{ print $6 * 2 }'
#+END_SRC

#+RESULTS:
:RESULTS:
total 113
-rw-r--r--+ 1 leunge Domain Users 28946 Sep  5 19:04 #unix_outline.org#
-rw-r--r--+ 1 leunge Domain Users   302 Sep  5 13:01 list_of_files.txt
-rw-r--r--+ 1 leunge Domain Users 50823 Sep  5 14:35 unix_outline.html
-rw-r--r--+ 1 leunge Domain Users 24879 Sep  5 14:29 unix_outline.org
 
28946 #unix_outline.org#
302 list_of_files.txt
50823 unix_outline.html
24879 unix_outline.org
0
57892
604
101646
49758
:END:

*** Resources and more

- [[https://dev.to/rrampage/awk---a-useful-little-language-2fhf][Awk - A useful little language]]
- [[https://www.lifewire.com/write-awk-commands-and-scripts-2200573][How to Write AWK Commands and Scripts]]
- [[https://www.thegeekstuff.com/2010/01/8-powerful-awk-built-in-variables-fs-ofs-rs-ors-nr-nf-filename-fnr/][8 Powerful Awk Built-in Variables (The Geek Stuff)]]
- [[http://www.grymoire.com/Unix/Awk.html][Awk (Grymoire)]]

** sed

The ~sed~ command is another powerful command. While ~awk~ is useful for
manipulating tabular data, ~sed~ is used to read in text and transform it.

A simple use of ~sed~ is for replacing text.

#+BEGIN_SRC sh
  echo Sunday | sed 's/day/night/'
#+END_SRC

#+RESULTS:
: Sunnight

*** Resources and more

- [[http://www.grymoire.com/Unix/Sed.html][sed (Grymoire)]]

** cut

The ~cut~ command is useful to divide a file into several parts.

It goes through each line to cut parts of it based on:

- byte position
- character
- field

#+BEGIN_SRC sh :results drawer
  ls -l
  ls -l | cut -b 1-10
#+END_SRC

#+RESULTS:
:RESULTS:
total 113
-rw-r--r--+ 1 leunge Domain Users 29867 Sep  5 19:25 #unix_outline.org#
-rw-r--r--+ 1 leunge Domain Users   302 Sep  5 13:01 list_of_files.txt
-rw-r--r--+ 1 leunge Domain Users 50823 Sep  5 14:35 unix_outline.html
-rw-r--r--+ 1 leunge Domain Users 24879 Sep  5 14:29 unix_outline.org
total 113
-rw-r--r--
-rw-r--r--
-rw-r--r--
-rw-r--r--
:END:

** find

The ~find~ command will be helpful to search for files.

The general form of this command is

#+BEGIN_SRC txt
  find (starting directory) (matching criteria and actions)
#+END_SRC

Here's a table summarizing the types of matching criteria available.

| Criteria   | Description                              |
|------------+------------------------------------------|
| -atime n   | File accessed n days ago                 |
| -mtime n   | File modified n days ago                 |
| -size n    | File is n blocks big (block = 512 bytes) |
| -type c    | File type, f=file,d=dir                  |
| -name nam  | Search filename nam                      |
| -user usr  | File's owner is usr                      |
| -group grp | File's group is grp                      |
| -perm p    | File's access mode is p                  |

Arithmetic modifiers can be used to specify values.

| Modifiers  | Description                          |
|------------+--------------------------------------|
| -mtime +7  | Modified more than seven days ago    |
| -atime -2  | File accessed less than two days ago |
| -size +100 | File larger than 100 blocks (50 KB)  |

#+BEGIN_SRC sh :results drawer
  # Look for text files accessed less than three days ago
  find . -atime -3 -name "*.txt"
#+END_SRC

#+RESULTS:
:RESULTS:
./list_of_files.txt
:END:

*** Resources and more

- [[https://www.tecmint.com/35-practical-examples-of-linux-find-command/][35 Practical Examples of Linux Find Command]]
- [[https://kb.iu.edu/d/admm][Use the Unix find command to search for files]]

* Bash Scripting

Similar to Python scripting, bash scripting is a quick way to:

- automate repetitive tasks
- create custom sequence of commands
- link together software tools written in different languages

** Local Variables

We covered variables very briefly when we talked about the ~$PATH~
variable. This is a built-in variable, but you can also create variables
yourself.

#+BEGIN_SRC sh
  university="Oregon Health & Science University"
  echo $university
#+END_SRC

#+RESULTS:
: Oregon Health & Science University

Mind that there should be *no space* around the equals sign.

And to call the variable, you need the *dollar sign* in front of the variable
name to use it.

Just a tease of what variables can do, you can save the output of one command
into a variable and then use it later.

#+BEGIN_SRC sh
  file_list=$(ls)
  echo $file_list
#+END_SRC

#+RESULTS:
: #unix_outline.org# unix_outline.html unix_outline.org

** Pass In Arguments

Sometimes, instead of hard-coding (explicitly typing in) file names into your
scripts, maybe we'd like our script to work with any file we give it.

Let's create a simple script that will count the number of lines a file has and
create a test file.

#+BEGIN_SRC sh :results drawer
  # Create a simple bash script to take in arguments
  echo '#!/usr/bin/env bash
  filename=$1

  if [ -r $filename ]; then
    linecount=$(wc -l < $filename)
    printf "%s has %d lines\n" $filename $linecount
  fi' > count_lines.sh
  cat count_lines.sh

  # The -e flag interprets backslash characters to create new lines with \n
  echo -e "This\nfile\nhas\nseven\nlines\nin\nit" > test_file.txt
  echo "" # Just create a space between results
  cat test_file.txt
#+END_SRC

#+RESULTS:
:RESULTS:
#!/usr/bin/env bash
filename=$1

if [ -r $filename ]; then
  linecount=$(wc -l < $filename)
  printf "%s has %d lines\n" $filename $linecount
fi

This
file
has
seven
lines
in
it
:END:

Now we can run the script we just created using the file we want as an
*argument*.

#+BEGIN_SRC sh :results verbatim
  bash count_lines.sh test_file.txt
#+END_SRC

#+RESULTS:
: test_file.txt has 7 lines

** Control Structures

Similar to Python, you can write statements in bash to control the flow of
logic based on conditions or loop through a list of items.

*** if/elif/else blocks

We briefly saw the ~if~ statement being used earlier.

The general syntax using conditional is:

#+BEGIN_SRC txt
  if [ expression ]; then
    Code is 'expression' is true
  fi
#+END_SRC

Here's a working example using ~if~ statements

#+BEGIN_SRC sh
  object="food"
  if [ $object == "car" ]; then
    echo "This is a car"
  elif [ $object == "food" ]; then
    echo "This is food"
  else
    echo "I don't know what this is"
  fi
#+END_SRC

#+RESULTS:
:RESULTS:
This is food
:END:

**** Resources and more

- [[http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-6.html][6. Conditionals]]

*** Various Conditions

Below are tables summarizing the various kinds of conditionals in bash.

**** Files and Directories

| Condition       | Description                      |
|-----------------+----------------------------------|
| [ -e file ]     | Check file exists                |
| [ -d directory] | Check directory exists           |
| [ -r file ]     | Check file exists and readable   |
| [ -w file ]     | Check file exists and writable   |
| [ -x file ]     | Check file exists and executable |

**** Compare Strings

| Condition              | Description                          |
|------------------------+--------------------------------------|
| [ -z STRING ]          | True if length of STRING is zero     |
| [ -n STRING ]          | True if length of STRING is non-zero |
| [ STRING1 == STRING2 ] | True if strings are equal            |
| [ STRING1 != STRING2 ] | True if strings are not equal        |
| [ STRING1 < STRING2 ]  | True if STRING1 sorts before STRING2 |
| [ STRING2 > STRING2 ]  | True if STRING1 sorts after STRING2  |

**** Numeric Comparisons

| Condition          | Description                        |
|--------------------+------------------------------------|
| [ NUM1 -eq NUM2 ]  | Two numbers are equal              |
| [ NUM1 -ne NUM2 ]  | Two numbers not equal              |
| [ NUM1 -gt NUM2 ]  | NUM1 greater than NUM2             |
| [ NUM1 -ge NUM2 ]  | NUM1 greater than or equal to NUM2 |
| [ NUM1 -lt NUM2 ]  | NUM1 less than NUM2                |
| [ NUM1 -le NUM2 ]  | NUM1 less than or equal to NUM2    |
| (( NUM1 == NUM2 )) | Two numbers are equal              |

*Note*: Double parentheses are specifically for arithmetic expressions. In
other words ~[ NUM1 > NUM2 ]~ would fail, but ~(( NUM1 > NUM2 ))~ would work.

**** Resources and more

- [[http://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_01.html][Introduction to if]]
- [[https://serverfault.com/questions/52034/what-is-the-difference-between-double-and-single-square-brackets-in-bash][What is the difference between double and single square brackets in bash?]]

*** while loops

The ~while~ loop keeps on running a set of commands *while* some condition is
still met.

#+BEGIN_SRC sh
  COUNTER=0
  while [ $COUNTER -lt 10 ]; do
    echo The counter is $COUNTER

    # let allows arithmetic expressions to be evaluated
    let COUNTER+=1
  done
#+END_SRC

#+RESULTS:
:RESULTS:
The counter is 0
The counter is 1
The counter is 2
The counter is 3
The counter is 4
The counter is 5
The counter is 6
The counter is 7
The counter is 8
The counter is 9
:END:

*** for loops

Similar to ~while~ loops, ~for~ loops will iterate over a set of commands. This
type of loop, however, loops over a list of items until that list is done.

#+BEGIN_SRC sh
  # Simple for loop example
  for i in 1 2 3 4; do
    echo $i
  done

  # Another way of the above
  echo
  for i in $(seq 1 4); do  # seq prints sequence of numbers
    echo $i
  done
#+END_SRC

#+RESULTS:
:RESULTS:
1
2
3
4

1
2
3
4
:END:



** Exit Status Indicators for Scripts

Unix and Linux systems have what are called *exit codes* that scripts/programs
can return after it is done running.

These codes indicate whether or not the script passed successfully (~0~),
failed in some way (~1~), or misuse of shell commands (~2~). There are a
variety of other codes for other situations.

Because scripts are typically run in the context of other scripts, it can be
important to know if any one of the inner scripts fail in someway so that you
can fix them.

To access the exit code of the previous script, you can use the ~$?~ variable.

#+BEGIN_SRC sh
  ls %  # <-- This will fail
  echo $?

  bashscript  # <-- Will also fail because non-existant
  echo $?
#+END_SRC

#+RESULTS:
:RESULTS:
2
127
:END:

Here is how you could use these within your own bash scripts.

#+BEGIN_SRC sh
  echo "#!/usr/bin/env bash

  head -n 1 ../README.md

  if [[ $? -eq 0 ]]; then
    echo 'Successfully read beginning of file'; exit 0
  else
    echo 'Failed to read beginning of file'; exit 1
  fi" > test_exit_codes.sh

  bash test_exit_codes.sh
#+END_SRC

#+RESULTS:
:RESULTS:
# Teaching Python's NetworkX and Bash
Successfully read beginning of file
:END:

*** Resources and more

- [[http://bencane.com/2014/09/02/understanding-exit-codes-and-how-to-use-them-in-bash-scripts/][Understanding Exit Codes and how to use them in bash scripts]]
- [[http://www.tldp.org/LDP/abs/html/exitcodes.html][Appendix E. Exit Codes with Special meanings]]
- [[https://bash.cyberciti.biz/guide/Exit_command][Exit command]]

* File Transfer and Interacting with the Web and Servers

When data analyses require compute power not available to your local computer,
a server dedicated to crunching numbers and analyses may be help.

When working with a server, you may want to move files between your own
computer and the server. While there are graphical tools to do this, there are
command line tools available to you to do this as well.

** curl and wget

~curl~ and ~wget~ are both command line tools that can download contents from
servers and the internet.

For simple file downloads, there isn't much of a difference in use.

*** curl

*Note*: the flags below are the letter O (as in ostrich), not the number zero (0).

#+BEGIN_SRC sh
  # Download Python's PEP 20 file
  curl -O https://raw.githubusercontent.com/python/peps/master/pep-0020.txt

  # Do the same thing, but name the downloaded file differently
  curl -o zen.txt https://raw.githubusercontent.com/python/peps/master/pep-0020.txt
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** wget

#+BEGIN_SRC sh
  # wget doesn't require any flags if you just want to download the file
  wget https://raw.githubusercontent.com/python/peps/master/pep-0020.txt

  # You can similarly name the downloaded file differently using the letter O
  wget -O https://raw.githubusercontent.com/python/peps/master/pep-0020.txt
#+END_SRC

*** Resources and more

- [[https://daniel.haxx.se/docs/curl-vs-wget.html][curl vs wget]]
- [[https://unix.stackexchange.com/questions/47434/what-is-the-difference-between-curl-and-wget][What is the difference between curl and wget?]]
- [[https://www.cyberciti.biz/faq/curl-download-file-example-under-linux-unix/][Linux/Unix: curl Command Download File Example]]
- [[https://www.cyberciti.biz/tips/linux-wget-your-ultimate-command-line-downloader.html][Linux wget: Your Ultimate Command Line Downloader]]
** scp and sftp

* Miscellaneously Useful Tools

** Screen and tmux

~Screen~ and ~tmux~ are called "terminal multiplexers".

This is a fancy way of describing how to use a single terminal window and
create new terminals from within it, without opening another window.

Here are some benefits to using a terminal multiplexer:

- Quickly switch between contexts
- Use when network connection unreliable
- Pick up progress quickly on a server when you login

**** Screen

Initially releases in 1987, Screen is a mature and stable terminal
multiplexer.

**** tmux

Initially created in 2007, tmux is also a terminal multiplexer with very
similar features compared to Screen.

*** Resources and More

- Manuals
  - [[https://www.gnu.org/software/screen/manual/html_node/index.html][Screen User's Manual]]
  - [[https://github.com/tmux/tmux/wiki][tmux GitHub Wiki]]
- Screen tutorials
  - [[https://www.linode.com/docs/networking/ssh/using-gnu-screen-to-manage-persistent-terminal-sessions/][Using GNU Screen to Manage Persistent Terminal Sessions - linode]]
  - [[https://www.mattcutts.com/blog/a-quick-tutorial-on-screen/][A quick tutorial on screen - Matt Cutts]]
  - [[https://dev.to/thiht/learn-to-use-screen-a-terminal-multiplexer-gl][Learn to use screen, a terminal multiplexer - dev.to]]
- tmux tutorials
  - [[https://robots.thoughtbot.com/a-tmux-crash-course][A tmux Crash Course - thoughtbot]]
  - [[https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/][A Quick and Easy Guide to tmux - Ham Vocke]]
  - [[https://danielmiessler.com/study/tmux/][A tmux Primer - Daniel Miessler]]
- Comparing terminal multiplexers
  - [[https://superuser.com/a/236160][tmux vs screen - supepruser]]
- More
  - [[https://leanpub.com/the-tao-of-tmux/read][The Tao of tmux - Leanpub]]

** GNU Make 

In programming, we want to no repeat ourselves. So people made GNU ~make~ as an
automation (build) tool.

This was initially used to systematically build and compile complex programs
with lots of dependencies. You will see this a lot with C/C++ programs.

However, this tool can also be used in automating tasks for data analysis and
describe exactly what you've done.

#+BEGIN_SRC txt
rule : dependencies
    commands ...
#+END_SRC

#+BEGIN_SRC makefile
article.html : article.md
     pandoc -i article.md -o article.html
#+END_SRC

A slightly better and more robust rule.

#+BEGIN_SRC makefile
all : article.html

%.html : %.md
    pandoc -i $< -o $@
#+END_SRC

Using the above ~Makefile~, you can use the command ~make all~ in the command
line to run the rule.

* Summary

| Command/Term | Simple Description               |
|--------------+----------------------------------|
| pwd          | Displays current directory       |
| ls           | Display files in directory       |
| cd           | Change current directory         |
| touch        | Update file or create new file   |
| cp           | Copy files and directories       |
| mv           | Move files and directories       |
| rm           | Delete files and directories     |
| mkdir        | Create new directory             |
| rmdir        | Remove empty directory           |
| STDIN        | Input going into program         |
| STDOUT       | Output coming out of programs    |
| STDERR       | Error messages                   |
| Pipe         | Pass text between commands       |
| awk          | Process text in tabular form     |
| sed          | Edit streams of data             |
| cut          | Divide file by column/delimiters |
| find         | Search for files                 |
| curl         | Transfer data                    |
| wget         | Retrieves contents from servers  |

* Exercises

* Resources and More

- [[http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html][Bash Guide for Beginners]] (Beginner)
- [[http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html][BASH Programming - Introduction HOW-TO]] (Intermediate)
- [[https://github.com/stephenturner/oneliners][Bioinformatics One-Liners by Stephen Turner]]
- [[http://mywiki.wooledge.org/BashPitfalls][Bash Pitfalls - Common Errors Bash Programmers Make]]
- [[https://github.com/denysdovhan/bash-handbook][bash-handbook (GitHub)]]
- [[https://sanctum.geek.nz/arabesque/series/unix-as-ide/][Unix as IDE Series]]
- [[https://github.com/awesome-lists/awesome-bash][Awesome Bash (GitHub)]]
